//+build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"text/template"
)

type RequiredFunction struct {
	Name    string
	ReqType string
	ResType string
}

type TemplateInput struct {
	Methods []RequiredFunction
}

const outputTemplateText = `// This file is generated by ./generate.go.  DO NOT EDIT.

package wasm

import (
	"context"
	"syscall/js"

	proto "github.com/golang/protobuf/proto"

	"github.com/Evertras/awf/lib/awfdata"
)

// Note: https://github.com/golang/go/commit/c468ad04177c422534ad1ed4547295935f84743d
// will make this much nicer... this is stolen from https://github.com/golang/go/issues/31335
// and is absolutely awful for performance, but okay for proof of concept for now
func typedArrayToByteSlice(arg js.Value) []byte {
	length := arg.Length()
	bytes := make([]byte, length)
	for i := 0; i < length; i++ {
		bytes[i] = byte(arg.Index(i).Int())
	}
	return bytes
}

// In the meantime we also will keep a single TypedArray that gets released when a new call
// is requested.  This *should* be safe since JS is single threaded and the returned array
// is immediately deserialized from its proto on the other end, and it'll keep memory from
// leaking on our end.
var returnedArray js.TypedArray

var server awfdata.WasmServiceServer = &wasmServer{}

func RegisterWasmCallbacks(base js.Value) {
<<range .Methods>>	base.Set("<<.Name>>", js.FuncOf(<<.Name>>))
<<end>>}

<<range .Methods>>
func <<.Name>>(this js.Value, args []js.Value) interface{} {
	msg := &awfdata.<<.ReqType>>{}

	// This is awful and should feel awful, but proof of concept... (see above)
	byteSlice := typedArrayToByteSlice(args[0])

	err := proto.Unmarshal(byteSlice, msg)

	if err != nil {
		panic(err)
	}

	res, err := server.<<.Name>>(context.Background(), msg)

	if err != nil {
		panic(err)
	}

	marshaled, err := proto.Marshal(res)

	if err != nil {
		panic(err)
	}

	// This is safe on initial zero value
	returnedArray.Release()
	returnedArray = js.TypedArrayOf(marshaled)

	return returnedArray
}
<<end>>
`

func main() {
	outputTemplate := template.Must(template.New("interface").Delims("<<", ">>").Parse(outputTemplateText))
	src, err := ioutil.ReadFile("../awfdata/svc_wasm.pb.go")

	if err != nil {
		panic(err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "svc_wasm.pb.go", src, 0)

	if err != nil {
		panic(err)
	}

	input := TemplateInput{
		Methods: make([]RequiredFunction, 0),
	}

	ast.Inspect(f, func(n ast.Node) bool {
		switch outer := n.(type) {
		case *ast.TypeSpec:
			if outer.Name.Name == "WasmServiceServer" {
				i := outer.Type.(*ast.InterfaceType)

				for _, method := range i.Methods.List {
					fn := method.Type.(*ast.FuncType)
					reqType := fn.Params.List[1].Type.(*ast.StarExpr)
					resType := fn.Results.List[0].Type.(*ast.StarExpr)

					input.Methods = append(input.Methods, RequiredFunction{
						Name:    method.Names[0].Name,
						ReqType: fmt.Sprintf("%s", reqType.X),
						ResType: fmt.Sprintf("%s", resType.X),
					})
				}

				return false
			}
		}

		return true
	})

	fout, err := os.Create("wasm_svc_adapter.go")

	if err != nil {
		panic(err)
	}

	defer fout.Close()

	err = outputTemplate.Execute(fout, input)

	if err != nil {
		panic(err)
	}

	fmt.Println("Done")
}
